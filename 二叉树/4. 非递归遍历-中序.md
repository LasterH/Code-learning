# 二叉树的非递归中序遍历

为什么中序遍历不同？

中序：左中右

访问元素的顺序和我们处理元素的顺序不一样

## 中序迭代法的过程

对于二叉树

```\c++
			5	
	4				6
1		2
```

先访问5，但是5不是我们要处理的元素

接着访问4，再访问1，才是我们需要处理的元素

```
需要一个指针帮助我们遍历二叉树
栈中是我们访问过的元素
先访问5，把5放入，一直向左访问
-------------------------
| 5   4   1
-------------------------
如果当前节点的左孩子为空，如果是空，就从栈中取出元素
-------------------------
| 5   4             ------>1     1
-------------------------
1加入到数组中，查询1的右孩子，如果是空，就从栈中弹出元素
-------------------------
| 5                 ------>4     1 4
-------------------------
接着访问4节点的右孩子，不为空，将其入栈
-------------------------
| 5   2
-------------------------
访问节点2的左孩子，为空，回到该节点并弹出
-------------------------
| 5                 ------>2     1 4 2
-------------------------
接着访问节点2的右孩子，为空，从栈中继续弹出元素
-------------------------
|                   ------>5     1 4 2 5
-------------------------
5的左孩子处理完了，将5的右孩子加入栈中
-------------------------
| 6                 ------>      1 4 2 5
-------------------------
6的左孩子为空，弹出6
-------------------------
|                   ------>6     1 4 2 5 6
-------------------------
6的右孩子也为空，应该从栈中弹出元素，栈为空
说明遍历已经结束
```

使用指针来遍历节点

用栈来记录我们遍历过的节点

栈弹出节点的顺序就是我们遍历树的顺序

## 代码实现

定义一个栈记录已经访问的元素

循环结束条件？

如果指针不为空，就一直查询左孩子

当左孩子为空时，处理栈顶节点，并且查询该节点右孩子

右孩子为空，依旧弹出栈顶元素

```c++
vector<int> traversol(root){
    vector<int> result;
    stack<ndoe> st;
    node* cur=root;
    while(cur!=null&&!st.empty()){
        if(cur!=null){
            st.push(cur);
            cur=cur->left;
        }else{
            cur=st.top();
            st.pop();
            result=push_back(cur->val);
            cur=cur->right;
        }
    }
    return result
}
```



