# KMP算法

## 理论篇

### KMP与解决的问题

字符串匹配问题

* 给出一个文本串：aabaabaaf
* 给出一个模式串：aabaaf
* 问在文本串中是否出现过模式串

### 暴力匹配

进行两层for循环遍历，第一层遍历文本串的起始匹配位置，第二层遍历模式串进行匹配

时间复杂度O(m×n)

### KMP算法

当第一个匹配b与f不匹配时，KMP不会从头移动，跳到之前匹配过的内容

f之间模式串的第一个aa匹配了文本串的第二个aa，因此模式串的b开始向文本串的第二个aa后的字符开始匹配

我们在匹配f后跳到b这里为什么？

* 之前的这个子串aabaa，它的后缀是aa，前缀也是aa，找到与这个后缀相等的前缀的后面重新开始匹配

* 因此要知道它的最长相等前后缀

**算法的关键在于：在当前对文本串和模式串检索的过程中，若出现了不匹配，如何充分利用已经匹配的部分。**

### 前缀表的由来

KMP如何知道之前匹配过那些？并且跳到那个已经匹配过的内容的后面开始匹配？

* 使用前缀表

前缀表有什么特性？

* 不重新开始匹配
* 最长相等前后缀

### 前缀与后缀

aabaaf中

前缀是包含首字母，不包含尾字母的所有子串

后缀是不包含首字母，包含尾字母的所有子串

### 最长相等前后缀

求最长相等的前缀和后缀的长度

对于aabaaf，求它子串的最长相等前后缀

* a：0
* aa：前缀a，后缀a，1
* aab：0
* aaba：1
* aabaa：2
* aabaaf：0
* 那么我们得到了模式串的前缀表：010120

### 使用前缀表的匹配过程

* 匹配过程中找到了冲突的位置，找到前面那个子串的最长相等前后缀

* 前缀表为2，说明有个后缀aa和一个前缀aa，在前缀的后面开始匹配，下标为最长相等前后缀的长度

在aabaaf匹配中，f不匹配，前面子串aabaa的前缀表为2，因为2表示的是相等前后缀的长度，因此从下标为2的元素开始匹配

### next数组

KMP算法会使用next数组

前缀表右移操作，或整体减一

这是两种不同的实现

### 总结

* 解决什么问题
* 为什么可以在匹配失败后跳到之前匹配的位置
* 为什么用前缀表不用哈希表
  1. **避免不必要的比较**：前缀表能够告诉我们在匹配失败时，模式串应该如何滑动，以避免重新比较已经匹配过的字符。哈希表不能提供这种信息。
  2. **空间效率**：前缀表仅需要存储每个位置的最长公共前后缀长度，通常是一个很小的整数数组。而哈希表则需要为每个子串存储一个哈希值，这通常需要更多的空间。
  3. **时间效率**：前缀表可以在O(n)时间内构建，其中n是模式串的长度。哈希表的构建和查询时间通常依赖于哈希函数的质量和冲突解决策略，可能不如前缀表高效。
  4. **避免哈希冲突**：哈希表存在哈希冲突的风险，这可能导致错误的结果。而前缀表则不存在这个问题。
  5. **易于理解和实现**：前缀表的概念相对简单，容易理解和实现。哈希表则需要更多的实现细节，如哈希函数的选择、冲突解决策略等。
* 前缀表特性
* 如何求取前缀表
* 前缀表匹配操作



## 代码篇

### next数组不同的实现方法

aabaaf的前缀表

010120

用next或者prefix来表示前缀表

**next数组实现方式**

* 把前缀表整体右移变成

   01012，再在前面加个-1，-101012

  遇见冲突后，找冲突的这个位置所对应的下标

* 全体减一变成

  -10-101-1

  遇见冲突后，找它前一位所对应的下标加1

这两种不同方法其实是表示我们面对冲突时去找的方式不同

### 具体代码

假设文本串为aabaabaaf，模式串为aabaaf

1. 初始化

   * 一个指针i，一个指针j

     * j指向前缀末尾位置，同时也表示i之前包括i子串的最长相等前后缀的长度

       因此j初始化为0

     * i指向后缀末尾位置

       i的初始化，进行到循环遍历过程

       i应该从1开始

   * next数组

     next[0]的值回退到0

2. 前后缀不同情况

   i和j表示的元素不相等，也就是前缀末尾和后缀末尾不匹配

   j就向前回退，根据它前一位的next数组的值

   回退到什么时候？

   * 初始位置是0，要让j>0
   * 回退是一个持续的过程，使用while

3. 相同情况

   j++，然后更新我们next数组的值

4. 更新

   因为j也表示i之前包括i子串的最长相等前后缀的长度

   直接将j的值赋给next[i]

```c++
void getNext(Next ,S){
    j=0;
    next[0]=0;
    for(i=1; i<S.size; i++){
        while(j>0&&s[i]!=s[j])
            j=next[j-1]
        if(s[i]==s[j]){
            j++;
        }
        next[i]=j;
    }
}
```

### 模拟运行过程

假设文本串为aabaabaaf，模式串为aabaaf

* 一轮循环后，j=1，i=2

  此时i和j对应的位置不相同

  j找它前一位所对应的下标，为0

  依然不相等，回到起始位置，无法回退

  进行更新next[i]的值

* 进行下一轮循环，j=0，i=3

  此时s[j]=s[i]，j++

  更新next[i]

  进行下一轮循环，j=1，i=4

  此时s[j]=s[i]，j++

  更新next[i]

* 进行下一轮循环，j=2，i=5

  此时s[j]!=s[i]

  j向前回退，前一位对应的值，为1，回到下标为1的位置

  此时依然不相等，继续回退，回退到下标为0的起始位置

  依然不相等

  更新next[i]

  

## 总结

```c++
#include <iostream>
#include <vector>
#include <string>

using namespace std;

// 函数用于计算 next 数组
void getNext(vector<int>& next, const string& s) {
    int j = 0;
    next[0] = 0;
    for (int i = 1; i < s.size(); i++) {
        while (j > 0 && s[i] != s[j]) {
            j = next[j - 1];
        }
        if (s[i] == s[j]) {
            j++;
        }
        next[i] = j;
    }
}

// KMP 算法主函数，用于检测模式串是否在文本串中出现
bool kmpSearch(const string& text, const string& pattern) {
    if (pattern.empty()) return true; // 空模式串匹配任何文本串
    if (text.empty()) return false;  // 非空模式串不匹配空文本串

    vector<int> next(pattern.size());
    getNext(next, pattern);

    int j = 0;
    for (int i = 0; i < text.size(); i++) {
        while (j > 0 && text[i] != pattern[j]) {
            j = next[j - 1];
        }
        if (text[i] == pattern[j]) {
            j++;
            if (j == pattern.size()) {
                return true; // 找到匹配
            }
        }
    }
    return false; // 未找到匹配
}

int main() {
    string text, pattern;
    cout << "请输入文本串: ";
    cin >> text;
    cout << "请输入模式串: ";
    cin >> pattern;

    if (kmpSearch(text, pattern)) {
        cout << "模式串在文本串中出现。" << endl;
    } else {
        cout << "模式串没有在文本串中出现。" << endl;
    }

    return 0;
}
```

