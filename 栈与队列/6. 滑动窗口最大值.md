# 滑动窗口最大值

LeetCode：239

给一个滑动窗口的范围，让滑动窗口去遍历我们的数组，放回滑动窗口内的最大值

对于大小为3的滑动窗口，遍历数组1、3、-1、-3、5、3、2、1

结果为：3、3、5、5、5、3

暴力求解：时间复杂度O(n×k)



## 整体思路

滑动过程很像一个队列

滑动窗口向后移动，`pop`一个元素，`push`一个元素，队列中始终存放着滑动窗口中的值

每次移动，找到队列中的最大值`getMaxValue`



优先级队列，大顶堆（不能解决这个问题）



因此，需要实现三个函数

* `pop`
* `push`
* `getMaxValue`

## 单调队列

**其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。**

那么这个维护元素单调递减的队列就叫做**单调队列，即单调递减或单调递增的队列。**

**不要以为实现的单调队列就是 对窗口里面的数进行排序，如果排序的话，那和优先级队列又有什么区别了呢。**

第一个窗口：

* 1放入

* 对于3，如果队列前面有比3小的元素，把前面的元素比3小全部弹出，直到前面没有比3小的元素

  这样维护出口处就是我们的最大值

* -1放入

* 队列为`3 -1`

* `getMaxValue`获得3

滑动窗口向后移动：

* 队列为`3 -1`
* 要实现窗口移动，应该弹出1，放入-3
* 此时出口处的最大值为3，还没到弹出3的时候，维护3，并且，本应该弹出的1，在维护出口处为最大值时已经被弹出，故不进行弹出操作
* 队列为`3 -1 -3`
* 获得3

向后移动：

* 队列为`3 -1 -3`
* 要实现窗口移动，应该弹出3，放入5
* 此时出口处的最大值为3，到了弹出的时候，弹出
* 把小于5的元素全部弹出
* 队列为`5`
* 获得5

向后移动：

* 队列为`5`
* 要实现窗口移动，应该弹出-1，放入3
* 此似乎出口处的最大值为5，还没到弹出5的时候，应该弹出的-1在维护出口处最大值时已经被弹出，不进行弹出操作
* 队列为`5 3`
* 获得5

向后移动：

* 队列为`5 3`
* 要实现窗口移动，应该弹出-3，放入2
* 队列为`5 3 2`
* 获得5

向后移动：

* 队列为`5 3 2`
* 要实现窗口移动，应该弹出5，放入1
* 队列为`3 2 1`
* 获得3

**也可以认为：最大值维护在队列出口处，如果**

数组中按照顺序需要弹出的值小于队列出口处的元素的话，说明需要弹出的元素早已在出口处元素入队列时被弹出，此时不需要再进行弹出操作

数组中按照顺序需要弹出的值等于队列出口处的元素的话与队列出口处的元素相同的话，说明现在要弹出的这个元素就是队列中最大的元素，弹出最大的元素



## 代码实现

定义一个类来实现我们的单调队列

1. 定义队列
2. 实现`pop`
3. 实现`push`
4. 实现`getMaxValue`

```c++
class MyQueue{
    public:
        deque<int>que;

        void pop(int val){
            if(!que.empty()&&que.front()==val)	que.pop_front();
        }

        void push(int val){
            while(!que.empty()&&val>que.back())
                que.pop_back();
            que.push_back(value)
        }

        int getMaxValue(){
            return que.front();
        }
}
```





## 错误想法

第一个窗口：

* 1放入

* 对于3，如果队列前面有比3小的元素，把前面的元素全部弹出，直到前面没有比3小的元素

  这样维护出口处就是我们的最大值

* -1放入

* 队列为`3 -1`

* `getMaxValue`获得3

滑动窗口向后移动：

* 队列为`3 -1`

* 1在上一步已经被`pop`走，此时队列未满，不需要弹出元素

* -3放入
* 队列为`3 -1 -3`
* 获得3

向后移动：

* 队列为`3 -1 -3`

* 此时队列已满，需要把3弹出
* 放入5，把小于5的元素全部弹出
* 队列为`5`
* 获得5

向后移动：

* 队列为`5`

* 队列未满
* 放入3
* 队列为`5 3`
* 获得5

向后移动：

* 队列为`5 3`
* 队列未满
* 放入2
* 队列为`5 3 2`
* 获得5

向后移动：

* 队列为`5 3 2`
* 队列已满，弹出5
* 放入1
* 队列为`3 2 1`
* 获得3

在上面过程中，队列中的最大值把窗口中本该在它前面的元素给挤出去了，也就是说，每次窗口向后移动的时候，如果队列不满，说明队列中有本该存在的元素被最大元素给挤出，这个操作已经代替了每次移动后弹出元素的操作。故直到队列满为止，移动的弹出操作以及被最大元素的弹出操作给执行