# 四数相加Ⅱ

LeetCode：454

给四个数组，要求在四个数组中分别找出一个元素，使四个元素相加为0，求四个元素组成的四元组的数量

不需要考虑去重操作

有A、B、C、D四个数组，我们可以考虑：

* 在A、B两个数组各取一个相加，将所有的结果放到一个集合里
* 在C、D两个数组各取一个相加，将所有的结果放到一个集合里
* 遍历AB集合，对于每个元素，查看CD集合中有没有我们想要的元素，也就是四个元素相加为0

为什么使用哈希法？

* 该问题可以转变为一个集合中的元素寻找另一个元素中的目标元素

使用什么哈希结构？

* 元素数值可能很大，考虑set或者map
* 我们不仅要统计a+b是否出现过，还要考虑a和b出现的次数，因此使用map

## map解题过程

* 遍历AB数组将a+b作为key，a+b出现的次数作为value构成集合
* 遍历CD数组，判断0-(c+d)有没有在集合中出现
* 定义变量count统计四元组的个数

## 注意事项

为什么AB分一个集合、CD分一个集合

* 降低时间复杂度

如何计算

* 集合中每出现一个0-(c+d)，count加上0-(c+d)所对应的value值

使用哪个map

* 使用unordered_map

## 代码实现

1. 定义一个map，count

2. 遍历A、B数组，将两元素和存储到map中

   `map[a+b]++`：如果map集合存在key为a+b的元素，则value++，没有则insert一个key为a+b的元素

   ```c++
   unordered_map <int,int> map;
   int count=0;
   for(a:A){
       for(b:B){
           map[a+b]++;
       }
   }
   ```

3. 遍历C、D数组，查找集合中有没有出现目标值

   ```c++
   for(c:C){
       for(d:D){
           target=0-(c+d);
           if(map.find(target)!=map.end())
               count+=map[taget];
       }
   }
   return count;
   ```

## 总结

一个for循环处理A数组，一个for循环处理B数组

处理A数组时选择容器给它填上元素，处理B数组时去容器中查找有没有我们需要的元素

